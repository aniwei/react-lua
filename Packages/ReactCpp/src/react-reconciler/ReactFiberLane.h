#pragma once

// Auto-generated by scripts/translate-react.js
// Source: react-main/packages/react-reconciler/src/ReactFiberLane.js

#include "shared/ReactFeatureFlags.h"
#include "react-reconciler/ReactRootTags.h"

#include <array>
#include <atomic>
#include <cstdint>
#include <functional>
#include <optional>
#include <string_view>
#include <unordered_set>
#include <vector>

namespace react {

using Lane = std::uint32_t;
using Lanes = std::uint32_t;

class FiberNode;
struct Transition {};

using TimeoutHandle = std::uintptr_t;
inline constexpr TimeoutHandle noTimeout = 0;

namespace detail {

inline constexpr std::size_t kTotalLanes = 31;

inline constexpr Lanes kNoLanes = 0b0000000000000000000000000000000u;
inline constexpr Lane kNoLane = 0b0000000000000000000000000000000u;

inline constexpr Lane kSyncHydrationLane = 0b0000000000000000000000000000001u;
inline constexpr Lane kSyncLane = 0b0000000000000000000000000000010u;
inline constexpr Lane kInputContinuousHydrationLane = 0b0000000000000000000000000000100u;
inline constexpr Lane kInputContinuousLane = 0b0000000000000000000000000001000u;
inline constexpr Lane kDefaultHydrationLane = 0b0000000000000000000000000010000u;
inline constexpr Lane kDefaultLane = 0b0000000000000000000000000100000u;
inline constexpr Lane kGestureLane = 0b0000000000000000000000001000000u;
inline constexpr Lane kTransitionHydrationLane = 0b0000000000000000000000010000000u;
inline constexpr Lane kTransitionLane1 = 0b0000000000000000000000100000000u;
inline constexpr Lane kTransitionLane2 = 0b0000000000000000000001000000000u;
inline constexpr Lane kTransitionLane3 = 0b0000000000000000000010000000000u;
inline constexpr Lane kTransitionLane4 = 0b0000000000000000000100000000000u;
inline constexpr Lane kTransitionLane5 = 0b0000000000000000001000000000000u;
inline constexpr Lane kTransitionLane6 = 0b0000000000000000010000000000000u;
inline constexpr Lane kTransitionLane7 = 0b0000000000000000100000000000000u;
inline constexpr Lane kTransitionLane8 = 0b0000000000000001000000000000000u;
inline constexpr Lane kTransitionLane9 = 0b0000000000000010000000000000000u;
inline constexpr Lane kTransitionLane10 = 0b0000000000000100000000000000000u;
inline constexpr Lane kTransitionLane11 = 0b0000000000001000000000000000000u;
inline constexpr Lane kTransitionLane12 = 0b0000000000010000000000000000000u;
inline constexpr Lane kTransitionLane13 = 0b0000000000100000000000000000000u;
inline constexpr Lane kTransitionLane14 = 0b0000000001000000000000000000000u;

inline constexpr Lanes kTransitionLanes = 0b0000000001111111111111100000000u;
inline constexpr Lanes kSyncUpdateLanes = kSyncLane | kInputContinuousLane | kDefaultLane;

inline constexpr Lanes kRetryLanes = 0b0000011110000000000000000000000u;
inline constexpr Lane kRetryLane1 = 0b0000000010000000000000000000000u;
inline constexpr Lane kRetryLane2 = 0b0000000100000000000000000000000u;
inline constexpr Lane kRetryLane3 = 0b0000001000000000000000000000000u;
inline constexpr Lane kRetryLane4 = 0b0000010000000000000000000000000u;

inline constexpr Lane kSelectiveHydrationLane = 0b0000100000000000000000000000000u;
inline constexpr Lanes kNonIdleLanes = 0b0000111111111111111111111111111u;
inline constexpr Lane kIdleHydrationLane = 0b0001000000000000000000000000000u;
inline constexpr Lane kIdleLane = 0b0010000000000000000000000000000u;
inline constexpr Lane kOffscreenLane = 0b0100000000000000000000000000000u;
inline constexpr Lane kDeferredLane = 0b1000000000000000000000000000000u;

inline constexpr Lanes kUpdateLanes = kSyncLane | kInputContinuousLane | kDefaultLane | kTransitionLanes;
inline constexpr Lanes kHydrationLanes = kSyncHydrationLane | kInputContinuousHydrationLane |
	kDefaultHydrationLane | kTransitionHydrationLane | kSelectiveHydrationLane |
	kIdleHydrationLane;

inline constexpr int kNoTimestamp = -1;
inline constexpr std::uint8_t kSyncLaneIndex = 1;

template <typename T>
using LaneMap = std::array<T, kTotalLanes>;

inline std::atomic<Lane> gNextTransitionLane{kTransitionLane1};
inline std::atomic<Lane> gNextRetryLane{kRetryLane1};

template <typename T>
[[nodiscard]] constexpr LaneMap<T> createLaneMap(const T& initial) {
	LaneMap<T> map{};
	for (auto& entry : map) {
		entry = initial;
	}
	return map;
}

[[nodiscard]] inline std::uint8_t pickArbitraryLaneIndex(Lanes lanes) {
	if (lanes == kNoLanes) {
		return 0;
	}
	std::uint8_t index = 0;
	while ((lanes & 1u) == 0u) {
		lanes >>= 1u;
		++index;
	}
	return index;
}

[[nodiscard]] inline Lane pickArbitraryLane(Lanes lanes) {
	if (lanes == kNoLanes) {
		return kNoLane;
	}
	return static_cast<Lane>(1u << pickArbitraryLaneIndex(lanes));
}

[[nodiscard]] inline Lanes getLanesOfEqualOrHigherPriority(Lanes lanes) {
	if (lanes == kNoLanes) {
		return kNoLanes;
	}
	lanes |= lanes >> 1;
	lanes |= lanes >> 2;
	lanes |= lanes >> 4;
	lanes |= lanes >> 8;
	lanes |= lanes >> 16;
	return lanes;
}

[[nodiscard]] inline std::uint8_t laneToIndex(Lane lane) {
	return pickArbitraryLaneIndex(lane);
}

[[nodiscard]] inline Lane claimNextTransitionLaneImpl() {
	Lane lane = gNextTransitionLane.load(std::memory_order_relaxed);
	Lane next = lane << 1;
	if ((next & kTransitionLanes) == kNoLanes) {
		next = kTransitionLane1;
	}
	gNextTransitionLane.store(next, std::memory_order_relaxed);
	return lane;
}

[[nodiscard]] inline Lane claimNextRetryLaneImpl() {
	Lane lane = gNextRetryLane.load(std::memory_order_relaxed);
	Lane next = lane << 1;
	if ((next & kRetryLanes) == kNoLanes) {
		next = kRetryLane1;
	}
	gNextRetryLane.store(next, std::memory_order_relaxed);
	return lane;
}

[[nodiscard]] constexpr bool includesSomeLane(Lanes lanes, Lanes mask) {
	return (lanes & mask) != 0;
}

[[nodiscard]] constexpr Lanes mergeLanes(Lanes a, Lanes b) {
	return a | b;
}

[[nodiscard]] constexpr Lanes subtractLanes(Lanes a, Lanes b) {
	return a & ~b;
}

[[nodiscard]] constexpr bool isSubsetOfLanes(Lanes set, Lanes subset) {
	return (set & subset) == subset;
}

[[nodiscard]] constexpr Lane getHighestPriorityLane(Lanes lanes) {
	return lanes == kNoLanes ? kNoLane : (lanes & static_cast<Lanes>(-static_cast<std::int32_t>(lanes)));
}

[[nodiscard]] constexpr Lanes getHighestPriorityLanes(Lanes lanes) {
	const Lanes pendingSyncLanes = lanes & kSyncUpdateLanes;
	if (pendingSyncLanes != kNoLanes) {
		return pendingSyncLanes;
	}
	switch (getHighestPriorityLane(lanes)) {
		case kSyncHydrationLane:
			return kSyncHydrationLane;
		case kSyncLane:
			return kSyncLane;
		case kInputContinuousHydrationLane:
			return kInputContinuousHydrationLane;
		case kInputContinuousLane:
			return kInputContinuousLane;
		case kDefaultHydrationLane:
			return kDefaultHydrationLane;
		case kDefaultLane:
			return kDefaultLane;
		case kGestureLane:
			return kGestureLane;
		case kTransitionHydrationLane:
			return kTransitionHydrationLane;
		case kTransitionLane1:
		case kTransitionLane2:
		case kTransitionLane3:
		case kTransitionLane4:
		case kTransitionLane5:
		case kTransitionLane6:
		case kTransitionLane7:
		case kTransitionLane8:
		case kTransitionLane9:
		case kTransitionLane10:
		case kTransitionLane11:
		case kTransitionLane12:
		case kTransitionLane13:
		case kTransitionLane14:
			return lanes & kTransitionLanes;
		case kRetryLane1:
		case kRetryLane2:
		case kRetryLane3:
		case kRetryLane4:
			return lanes & kRetryLanes;
		case kSelectiveHydrationLane:
			return kSelectiveHydrationLane;
		case kIdleHydrationLane:
			return kIdleHydrationLane;
		case kIdleLane:
			return kIdleLane;
		case kOffscreenLane:
			return kOffscreenLane;
		case kDeferredLane:
			return kNoLanes;
		default:
			return lanes;
	}
}

[[nodiscard]] inline std::optional<std::string_view> getLabelForLane(Lane lane) {
	using namespace std::string_view_literals;
	if (!enableSchedulingProfiler) {
		return std::nullopt;
	}
	if (lane & kSyncHydrationLane) {
		return "SyncHydrationLane"sv;
	}
	if (lane & kSyncLane) {
		return "Sync"sv;
	}
	if (lane & kInputContinuousHydrationLane) {
		return "InputContinuousHydration"sv;
	}
	if (lane & kInputContinuousLane) {
		return "InputContinuous"sv;
	}
	if (lane & kDefaultHydrationLane) {
		return "DefaultHydration"sv;
	}
	if (lane & kDefaultLane) {
		return "Default"sv;
	}
	if (lane & kTransitionHydrationLane) {
		return "TransitionHydration"sv;
	}
	if (lane & kTransitionLanes) {
		return "Transition"sv;
	}
	if (lane & kRetryLanes) {
		return "Retry"sv;
	}
	if (lane & kSelectiveHydrationLane) {
		return "SelectiveHydration"sv;
	}
	if (lane & kIdleHydrationLane) {
		return "IdleHydration"sv;
	}
	if (lane & kIdleLane) {
		return "Idle"sv;
	}
	if (lane & kOffscreenLane) {
		return "Offscreen"sv;
	}
	if (lane & kDeferredLane) {
		return "Deferred"sv;
	}
	return std::nullopt;
}

} // namespace detail

inline constexpr std::size_t TotalLanes = detail::kTotalLanes;
inline constexpr Lanes NoLanes = detail::kNoLanes;
inline constexpr Lane NoLane = detail::kNoLane;
inline constexpr Lane SyncHydrationLane = detail::kSyncHydrationLane;
inline constexpr Lane SyncLane = detail::kSyncLane;
inline constexpr std::uint8_t SyncLaneIndex = detail::kSyncLaneIndex;
inline constexpr Lane InputContinuousHydrationLane = detail::kInputContinuousHydrationLane;
inline constexpr Lane InputContinuousLane = detail::kInputContinuousLane;
inline constexpr Lane DefaultHydrationLane = detail::kDefaultHydrationLane;
inline constexpr Lane DefaultLane = detail::kDefaultLane;
inline constexpr Lane GestureLane = detail::kGestureLane;
inline constexpr Lane TransitionHydrationLane = detail::kTransitionHydrationLane;
inline constexpr Lanes TransitionLanes = detail::kTransitionLanes;
inline constexpr Lane TransitionLane1 = detail::kTransitionLane1;
inline constexpr Lane TransitionLane2 = detail::kTransitionLane2;
inline constexpr Lane TransitionLane3 = detail::kTransitionLane3;
inline constexpr Lane TransitionLane4 = detail::kTransitionLane4;
inline constexpr Lane TransitionLane5 = detail::kTransitionLane5;
inline constexpr Lane TransitionLane6 = detail::kTransitionLane6;
inline constexpr Lane TransitionLane7 = detail::kTransitionLane7;
inline constexpr Lane TransitionLane8 = detail::kTransitionLane8;
inline constexpr Lane TransitionLane9 = detail::kTransitionLane9;
inline constexpr Lane TransitionLane10 = detail::kTransitionLane10;
inline constexpr Lane TransitionLane11 = detail::kTransitionLane11;
inline constexpr Lane TransitionLane12 = detail::kTransitionLane12;
inline constexpr Lane TransitionLane13 = detail::kTransitionLane13;
inline constexpr Lane TransitionLane14 = detail::kTransitionLane14;
inline constexpr Lanes RetryLanes = detail::kRetryLanes;
inline constexpr Lane RetryLane1 = detail::kRetryLane1;
inline constexpr Lane RetryLane2 = detail::kRetryLane2;
inline constexpr Lane RetryLane3 = detail::kRetryLane3;
inline constexpr Lane RetryLane4 = detail::kRetryLane4;
inline constexpr Lane SomeRetryLane = RetryLane1;
inline constexpr Lane SelectiveHydrationLane = detail::kSelectiveHydrationLane;
inline constexpr Lanes NonIdleLanes = detail::kNonIdleLanes;
inline constexpr Lane IdleHydrationLane = detail::kIdleHydrationLane;
inline constexpr Lane IdleLane = detail::kIdleLane;
inline constexpr Lane OffscreenLane = detail::kOffscreenLane;
inline constexpr Lane DeferredLane = detail::kDeferredLane;
inline constexpr Lanes UpdateLanes = detail::kUpdateLanes;
inline constexpr Lanes HydrationLanes = detail::kHydrationLanes;
inline constexpr Lanes SyncUpdateLanes = detail::kSyncUpdateLanes;
inline constexpr int NoTimestamp = detail::kNoTimestamp;

struct ConcurrentUpdate {
	Lane lane{NoLane};
	ConcurrentUpdate* next{nullptr};
};

template <typename T>
using LaneMap = detail::LaneMap<T>;

template <typename T>
[[nodiscard]] constexpr LaneMap<T> createLaneMap(const T& initial) {
	return detail::createLaneMap(initial);
}

[[nodiscard]] constexpr bool includesSomeLane(Lanes lanes, Lanes mask) {
	return detail::includesSomeLane(lanes, mask);
}

[[nodiscard]] constexpr Lanes mergeLanes(Lanes a, Lanes b) {
	return detail::mergeLanes(a, b);
}

[[nodiscard]] constexpr Lanes subtractLanes(Lanes a, Lanes b) {
	return detail::subtractLanes(a, b);
}

[[nodiscard]] constexpr bool isSubsetOfLanes(Lanes set, Lanes subset) {
	return detail::isSubsetOfLanes(set, subset);
}

[[nodiscard]] constexpr Lane getHighestPriorityLane(Lanes lanes) {
	return detail::getHighestPriorityLane(lanes);
}

[[nodiscard]] constexpr Lanes getHighestPriorityLanes(Lanes lanes) {
	return detail::getHighestPriorityLanes(lanes);
}

[[nodiscard]] inline std::optional<std::string_view> getLabelForLane(Lane lane) {
	return detail::getLabelForLane(lane);
}

[[nodiscard]] inline std::uint8_t pickArbitraryLaneIndex(Lanes lanes) {
	return detail::pickArbitraryLaneIndex(lanes);
}

[[nodiscard]] inline Lane pickArbitraryLane(Lanes lanes) {
	return detail::pickArbitraryLane(lanes);
}

[[nodiscard]] inline std::uint8_t laneToIndex(Lane lane) {
	return detail::laneToIndex(lane);
}

[[nodiscard]] inline Lanes getLanesOfEqualOrHigherPriority(Lanes lanes) {
	return detail::getLanesOfEqualOrHigherPriority(lanes);
}

[[nodiscard]] inline Lane claimNextTransitionLane() {
	return detail::claimNextTransitionLaneImpl();
}

[[nodiscard]] inline Lane claimNextRetryLane() {
	return detail::claimNextRetryLaneImpl();
}

[[nodiscard]] constexpr Lanes removeLanes(Lanes set, Lanes subset) {
	return subtractLanes(set, subset);
}

[[nodiscard]] constexpr Lanes intersectLanes(Lanes a, Lanes b) {
	return a & b;
}

[[nodiscard]] constexpr Lanes laneToLanes(Lane lane) {
	return lane;
}

[[nodiscard]] constexpr Lane higherPriorityLane(Lane a, Lane b) {
	return (a != NoLane && a < b) ? a : b;
}

[[nodiscard]] constexpr bool includesSyncLane(Lanes lanes) {
	return (lanes & (SyncLane | SyncHydrationLane)) != NoLanes;
}

[[nodiscard]] constexpr bool includesNonIdleWork(Lanes lanes) {
	return (lanes & NonIdleLanes) != NoLanes;
}

[[nodiscard]] constexpr bool includesOnlyRetries(Lanes lanes) {
	return (lanes & RetryLanes) == lanes;
}

[[nodiscard]] constexpr bool includesOnlyNonUrgentLanes(Lanes lanes) {
	constexpr Lanes kUrgentLanes = SyncLane | InputContinuousLane | DefaultLane;
	return (lanes & kUrgentLanes) == NoLanes;
}

[[nodiscard]] constexpr bool includesOnlyTransitions(Lanes lanes) {
	return (lanes & TransitionLanes) == lanes;
}

[[nodiscard]] constexpr bool includesTransitionLane(Lanes lanes) {
	return (lanes & TransitionLanes) != NoLanes;
}

[[nodiscard]] constexpr bool includesOnlyHydrationLanes(Lanes lanes) {
	return (lanes & HydrationLanes) == lanes;
}

[[nodiscard]] constexpr bool includesOnlyOffscreenLanes(Lanes lanes) {
	return (lanes & OffscreenLane) == lanes;
}

[[nodiscard]] constexpr bool includesOnlyHydrationOrOffscreenLanes(Lanes lanes) {
	return (lanes & (HydrationLanes | OffscreenLane)) == lanes;
}

[[nodiscard]] constexpr bool includesOnlyViewTransitionEligibleLanes(Lanes lanes) {
	constexpr Lanes kMask = TransitionLanes | RetryLanes | IdleLane;
	return (lanes & kMask) == lanes;
}

[[nodiscard]] constexpr bool includesOnlySuspenseyCommitEligibleLanes(Lanes lanes) {
	constexpr Lanes kMask = TransitionLanes | RetryLanes | IdleLane | GestureLane;
	return (lanes & kMask) == lanes;
}

[[nodiscard]] constexpr bool includesLoadingIndicatorLanes(Lanes lanes) {
	return (lanes & (SyncLane | DefaultLane)) != NoLanes;
}

[[nodiscard]] constexpr bool includesBlockingLane(Lanes lanes) {
	constexpr Lanes kMask = InputContinuousHydrationLane | InputContinuousLane | DefaultHydrationLane |
		DefaultLane | GestureLane;
	return (lanes & kMask) != NoLanes;
}

[[nodiscard]] constexpr bool isBlockingLane(Lane lane) {
	constexpr Lane kMask = InputContinuousHydrationLane | InputContinuousLane | DefaultHydrationLane |
		DefaultLane;
	return (lane & kMask) != NoLanes;
}

[[nodiscard]] constexpr bool isTransitionLane(Lane lane) {
	return (lane & TransitionLanes) != NoLanes;
}

[[nodiscard]] constexpr bool isGestureRender(Lanes lanes) {
	return lanes == GestureLane;
}

enum class LanePriority : std::uint8_t {
	NoLanePriority = 0,
	SyncLanePriority = 1,
	InputContinuousLanePriority = 2,
	DefaultLanePriority = 3,
	TransitionLanePriority = 4,
	RetryLanePriority = 5,
	IdleLanePriority = 6,
	OffscreenLanePriority = 7,
};

[[nodiscard]] constexpr LanePriority lanePriorityForLane(Lane lane) {
	if (lane == NoLane) {
		return LanePriority::NoLanePriority;
	}
	if (lane & (SyncLane | SyncHydrationLane)) {
		return LanePriority::SyncLanePriority;
	}
	if (lane & (InputContinuousLane | InputContinuousHydrationLane | GestureLane)) {
		return LanePriority::InputContinuousLanePriority;
	}
	if (lane & (DefaultLane | DefaultHydrationLane)) {
		return LanePriority::DefaultLanePriority;
	}
	if (lane & (TransitionHydrationLane | TransitionLanes)) {
		return LanePriority::TransitionLanePriority;
	}
	if (lane & RetryLanes) {
		return LanePriority::RetryLanePriority;
	}
	if (lane & (IdleLane | IdleHydrationLane)) {
		return LanePriority::IdleLanePriority;
	}
	if (lane & (OffscreenLane | DeferredLane | SelectiveHydrationLane)) {
		return LanePriority::OffscreenLanePriority;
	}
	return LanePriority::DefaultLanePriority;
}

[[nodiscard]] constexpr LanePriority lanesToLanePriority(Lanes lanes) {
	return lanePriorityForLane(getHighestPriorityLane(lanes));
}

[[nodiscard]] constexpr bool isLanePriorityHigher(LanePriority a, LanePriority b) {
	const auto priorityA = static_cast<std::uint8_t>(a);
	const auto priorityB = static_cast<std::uint8_t>(b);
	if (priorityA == 0) {
		return false;
	}
	if (priorityB == 0) {
		return true;
	}
	return priorityA < priorityB;
}

[[nodiscard]] constexpr LanePriority higherLanePriority(LanePriority a, LanePriority b) {
	return isLanePriorityHigher(a, b) ? a : b;
}

struct FiberRoot {
	FiberNode* current{nullptr};
	TimeoutHandle timeoutHandle{noTimeout};
	std::function<void()> cancelPendingCommit{};
	RootTag tag{RootTag::LegacyRoot};
	Lanes pendingLanes{NoLanes};
	Lanes suspendedLanes{NoLanes};
	Lanes pingedLanes{NoLanes};
	Lanes warmLanes{NoLanes};
	Lanes expiredLanes{NoLanes};
	Lanes entangledLanes{NoLanes};
	LaneMap<Lanes> entanglements{createLaneMap<Lanes>(NoLanes)};
	Lanes errorRecoveryDisabledLanes{NoLanes};
	Lanes indicatorLanes{NoLanes};
	LaneMap<int> expirationTimes{createLaneMap<int>(NoTimestamp)};
	int shellSuspendCounter{0};
	LaneMap<std::optional<std::vector<ConcurrentUpdate*>>> hiddenUpdates{
		createLaneMap<std::optional<std::vector<ConcurrentUpdate*>>>(std::nullopt)};
	LaneMap<std::unordered_set<const FiberNode*>> pendingUpdatersLaneMap{
		createLaneMap<std::unordered_set<const FiberNode*>>(
			std::unordered_set<const FiberNode*>{})};
	std::unordered_set<const FiberNode*> memoizedUpdaters{};
	LaneMap<std::optional<std::unordered_set<const Transition*>>> transitionLanes{
		createLaneMap<std::optional<std::unordered_set<const Transition*>>>(std::nullopt)};
};

[[nodiscard]] inline int computeExpirationTime(Lane lane, int currentTime) {
	switch (lane) {
		case SyncHydrationLane:
		case SyncLane:
		case InputContinuousHydrationLane:
		case InputContinuousLane:
		case GestureLane:
			return currentTime + syncLaneExpirationMs;
		case DefaultHydrationLane:
		case DefaultLane:
		case TransitionHydrationLane:
		case TransitionLane1:
		case TransitionLane2:
		case TransitionLane3:
		case TransitionLane4:
		case TransitionLane5:
		case TransitionLane6:
		case TransitionLane7:
		case TransitionLane8:
		case TransitionLane9:
		case TransitionLane10:
		case TransitionLane11:
		case TransitionLane12:
		case TransitionLane13:
		case TransitionLane14:
			return currentTime + transitionLaneExpirationMs;
		case RetryLane1:
		case RetryLane2:
		case RetryLane3:
		case RetryLane4:
			return enableRetryLaneExpiration ? currentTime + retryLaneExpirationMs : NoTimestamp;
		case SelectiveHydrationLane:
		case IdleHydrationLane:
		case IdleLane:
		case OffscreenLane:
		case DeferredLane:
			return NoTimestamp;
		default:
			return NoTimestamp;
	}
}

inline void markRootUpdated(FiberRoot& root, Lane updateLane) {
	root.pendingLanes |= updateLane;
	if (enableDefaultTransitionIndicator) {
		root.indicatorLanes |= updateLane & TransitionLanes;
	}
	if (updateLane != IdleLane) {
		root.suspendedLanes = NoLanes;
		root.pingedLanes = NoLanes;
		root.warmLanes = NoLanes;
	}
}

inline void markSpawnedDeferredLane(FiberRoot& root, Lane spawnedLane, Lanes entangledLanes) {
	root.pendingLanes |= spawnedLane;
	root.suspendedLanes &= ~spawnedLane;

	const auto spawnedLaneIndex = laneToIndex(spawnedLane);
	root.entangledLanes |= spawnedLane;
	root.entanglements[spawnedLaneIndex] |= DeferredLane | (entangledLanes & UpdateLanes);
}

inline void markRootSuspended(FiberRoot& root, Lanes suspendedLanes, Lane spawnedLane, bool didAttemptEntireTree) {
	root.suspendedLanes |= suspendedLanes;
	root.pingedLanes &= ~suspendedLanes;

	if (didAttemptEntireTree) {
		root.warmLanes |= suspendedLanes;
	}

	Lanes lanes = suspendedLanes;
	while (lanes != NoLanes) {
		const auto index = pickArbitraryLaneIndex(lanes);
		const auto lane = static_cast<Lane>(1u << index);
		root.expirationTimes[index] = NoTimestamp;
		lanes &= ~lane;
	}

	if (spawnedLane != NoLane) {
		markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);
	}
}

inline void markRootPinged(FiberRoot& root, Lanes pingedLanes) {
	root.pingedLanes |= root.suspendedLanes & pingedLanes;
	root.warmLanes &= ~pingedLanes;
}

[[nodiscard]] inline bool checkIfRootIsPrerendering(const FiberRoot& root, Lanes renderLanes) {
	const Lanes pendingLanes = root.pendingLanes;
	const Lanes suspendedLanes = root.suspendedLanes;
	const Lanes pingedLanes = root.pingedLanes;
	const Lanes nonSuspendedPendingLanes = pendingLanes & ~(suspendedLanes & ~pingedLanes);
	return (nonSuspendedPendingLanes & renderLanes) == NoLanes;
}

inline void markRootFinished(
	FiberRoot& root,
	Lanes finishedLanes,
	Lanes remainingLanes,
	Lane spawnedLane,
	Lanes updatedLanes,
	Lanes suspendedRetryLanes) {
	const Lanes previouslyPendingLanes = root.pendingLanes;
	const Lanes noLongerPendingLanes = previouslyPendingLanes & ~remainingLanes;

	root.pendingLanes = remainingLanes;
	root.suspendedLanes = NoLanes;
	root.pingedLanes = NoLanes;
	root.warmLanes = NoLanes;

	if (enableDefaultTransitionIndicator) {
		root.indicatorLanes &= remainingLanes;
	}

	root.expiredLanes &= remainingLanes;
	root.entangledLanes &= remainingLanes;
	root.errorRecoveryDisabledLanes &= remainingLanes;
	root.shellSuspendCounter = 0;

	auto& entanglements = root.entanglements;
	auto& expirationTimes = root.expirationTimes;
	auto& hiddenUpdates = root.hiddenUpdates;

	Lanes lanes = noLongerPendingLanes;
	while (lanes != NoLanes) {
		const auto index = pickArbitraryLaneIndex(lanes);
		const auto lane = static_cast<Lane>(1u << index);

		entanglements[index] = NoLanes;
		expirationTimes[index] = NoTimestamp;

		auto& hiddenSlot = hiddenUpdates[index];
		if (hiddenSlot.has_value()) {
			for (auto* update : *hiddenSlot) {
				if (update != nullptr) {
					update->lane &= ~OffscreenLane;
				}
			}
			hiddenSlot.reset();
		}

		lanes &= ~lane;
	}

	if (spawnedLane != NoLane) {
		markSpawnedDeferredLane(root, spawnedLane, NoLanes);
	}

	if (suspendedRetryLanes != NoLanes && updatedLanes == NoLanes &&
		!(disableLegacyMode && root.tag == RootTag::LegacyRoot)) {
		const Lanes freshlySpawnedRetryLanes =
			suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes);
		root.suspendedLanes |= freshlySpawnedRetryLanes;
	}
}

inline void markStarvedLanesAsExpired(FiberRoot& root, int currentTime) {
	Lanes lanes = enableRetryLaneExpiration ? root.pendingLanes : removeLanes(root.pendingLanes, RetryLanes);
	while (lanes != NoLanes) {
		const auto index = pickArbitraryLaneIndex(lanes);
		const auto lane = static_cast<Lane>(1u << index);
		const int expirationTime = root.expirationTimes[index];
		if (expirationTime == NoTimestamp) {
			const bool laneSuspended = (lane & root.suspendedLanes) != NoLanes;
			const bool lanePinged = (lane & root.pingedLanes) != NoLanes;
			if (!laneSuspended || lanePinged) {
				root.expirationTimes[index] = computeExpirationTime(lane, currentTime);
			}
		} else if (expirationTime <= currentTime) {
			root.expiredLanes |= lane;
		}
		lanes &= ~lane;
	}
}

[[nodiscard]] inline Lanes getEntangledLanes(const FiberRoot& root, Lanes renderLanes) {
	Lanes entangledLanes = renderLanes;
	if ((entangledLanes & InputContinuousLane) != NoLanes) {
		entangledLanes |= entangledLanes & DefaultLane;
	}

	const Lanes rootEntangled = root.entangledLanes;
	if (rootEntangled != NoLanes) {
		const auto& entanglements = root.entanglements;
		Lanes lanes = entangledLanes & rootEntangled;
		while (lanes != NoLanes) {
			const auto index = pickArbitraryLaneIndex(lanes);
			const auto lane = static_cast<Lane>(1u << index);
			entangledLanes |= entanglements[index];
			lanes &= ~lane;
		}
	}

	return entangledLanes;
}

[[nodiscard]] inline Lanes getHighestPriorityPendingLanes(const FiberRoot& root) {
	return getHighestPriorityLanes(root.pendingLanes);
}

[[nodiscard]] inline Lanes getLanesToRetrySynchronouslyOnError(
	const FiberRoot& root,
	Lanes originallyAttemptedLanes) {
	if ((root.errorRecoveryDisabledLanes & originallyAttemptedLanes) != NoLanes) {
		return NoLanes;
	}

	const Lanes everythingButOffscreen = root.pendingLanes & ~OffscreenLane;
	if (everythingButOffscreen != NoLanes) {
		return everythingButOffscreen;
	}
	if ((everythingButOffscreen & OffscreenLane) != NoLanes) {
		return OffscreenLane;
	}
	return NoLanes;
}

[[nodiscard]] inline bool includesExpiredLane(const FiberRoot& root, Lanes lanes) {
	return (lanes & root.expiredLanes) != NoLanes;
}

inline void markRootEntangled(FiberRoot& root, Lanes entangledLanes) {
	const Lanes rootEntangled = (root.entangledLanes |= entangledLanes);
	auto& entanglements = root.entanglements;
	Lanes lanes = rootEntangled;
	while (lanes != NoLanes) {
		const auto index = pickArbitraryLaneIndex(lanes);
		const auto lane = static_cast<Lane>(1u << index);
		if (((lane & entangledLanes) != NoLanes) || ((entanglements[index] & entangledLanes) != NoLanes)) {
			entanglements[index] |= entangledLanes;
		}
		lanes &= ~lane;
	}
}

inline void upgradePendingLanesToSync(FiberRoot& root, Lanes lanesToUpgrade) {
	root.pendingLanes |= SyncLane;
	root.entangledLanes |= SyncLane;
	Lanes lanes = lanesToUpgrade;
	while (lanes != NoLanes) {
		const auto index = pickArbitraryLaneIndex(lanes);
		const auto lane = static_cast<Lane>(1u << index);
		root.entanglements[SyncLaneIndex] |= lane;
		lanes &= ~lane;
	}
}

inline void markHiddenUpdate(FiberRoot& root, ConcurrentUpdate* update, Lane lane) {
	if (update == nullptr) {
		return;
	}
	const auto index = laneToIndex(lane);
	auto& hiddenSlot = root.hiddenUpdates[index];
	if (!hiddenSlot.has_value()) {
		hiddenSlot.emplace();
	}
	hiddenSlot->push_back(update);
	update->lane = lane | OffscreenLane;
}

[[nodiscard]] inline Lane getBumpedLaneForHydrationByLane(Lane lane) {
	switch (lane) {
		case SyncLane:
			return SyncHydrationLane;
		case InputContinuousLane:
			return InputContinuousHydrationLane;
		case DefaultLane:
			return DefaultHydrationLane;
		case TransitionLane1:
		case TransitionLane2:
		case TransitionLane3:
		case TransitionLane4:
		case TransitionLane5:
		case TransitionLane6:
		case TransitionLane7:
		case TransitionLane8:
		case TransitionLane9:
		case TransitionLane10:
		case TransitionLane11:
		case TransitionLane12:
		case TransitionLane13:
		case TransitionLane14:
		case RetryLane1:
		case RetryLane2:
		case RetryLane3:
		case RetryLane4:
			return TransitionHydrationLane;
		case IdleLane:
			return IdleHydrationLane;
		default:
			return NoLane;
	}
}

[[nodiscard]] inline Lane getBumpedLaneForHydration(const FiberRoot& root, Lanes renderLanes) {
	const Lane renderLane = getHighestPriorityLane(renderLanes);
	const Lane bumpedLane =
		(renderLane & SyncUpdateLanes) != NoLane ? SyncHydrationLane : getBumpedLaneForHydrationByLane(renderLane);
	if ((bumpedLane & (root.suspendedLanes | renderLanes)) != NoLane) {
		return NoLane;
	}
	return bumpedLane;
}

[[nodiscard]] inline LanePriority getHighestPriorityPendingLanePriority(const FiberRoot& root) {
	return lanesToLanePriority(root.pendingLanes);
}

[[nodiscard]] inline Lane getHighestPriorityPendingLane(const FiberRoot& root) {
	return getHighestPriorityLane(root.pendingLanes);
}

[[nodiscard]] inline std::string_view getGroupNameOfHighestPriorityLane(Lanes lanes) {
	using namespace std::string_view_literals;
	if ((lanes & (SyncHydrationLane | SyncLane | InputContinuousHydrationLane | InputContinuousLane | DefaultHydrationLane | DefaultLane | GestureLane)) != NoLanes) {
		return "Blocking"sv;
	}
	if ((lanes & (TransitionHydrationLane | TransitionLanes)) != NoLanes) {
		return "Transition"sv;
	}
	if ((lanes & RetryLanes) != NoLanes) {
		return "Suspense"sv;
	}
	if ((lanes & (SelectiveHydrationLane | IdleHydrationLane | IdleLane | OffscreenLane | DeferredLane)) != NoLanes) {
		return "Idle"sv;
	}
	return "Other"sv;
}

inline void addFiberToLanesMap(FiberRoot& root, const FiberNode* fiber, Lanes lanes) {
	if (!enableUpdaterTracking) {
		return;
	}
	if (fiber == nullptr) {
		return;
	}
	Lanes remaining = lanes;
	while (remaining != NoLanes) {
		const auto index = pickArbitraryLaneIndex(remaining);
		const auto lane = static_cast<Lane>(1u << index);
		root.pendingUpdatersLaneMap[index].insert(fiber);
		remaining &= ~lane;
	}
}

inline void addTransitionToLanesMap(FiberRoot& root, const Transition* transition, Lane lane) {
	if (!enableTransitionTracing || transition == nullptr || lane == NoLane) {
		return;
	}
	const auto index = laneToIndex(lane);
	auto& slot = root.transitionLanes[index];
	if (!slot.has_value()) {
		slot.emplace();
	}
	slot->insert(transition);
}

[[nodiscard]] inline std::vector<const Transition*> getTransitionsForLanes(const FiberRoot& root, Lanes lanes) {
	if (!enableTransitionTracing || lanes == NoLanes) {
		return {};
	}
	std::vector<const Transition*> transitions;
	std::unordered_set<const Transition*> seen;
	Lanes remaining = lanes;
	while (remaining != NoLanes) {
		const auto index = pickArbitraryLaneIndex(remaining);
		const auto lane = static_cast<Lane>(1u << index);
		const auto& slot = root.transitionLanes[index];
		if (slot.has_value()) {
			for (const auto* entry : *slot) {
				if (entry != nullptr && seen.insert(entry).second) {
					transitions.push_back(entry);
				}
			}
		}
		remaining &= ~lane;
	}
	return transitions;
}

inline void clearTransitionsForLanes(FiberRoot& root, Lanes lanes) {
	if (!enableTransitionTracing || lanes == NoLanes) {
		return;
	}
	Lanes remaining = lanes;
	while (remaining != NoLanes) {
		const auto index = pickArbitraryLaneIndex(remaining);
		const auto lane = static_cast<Lane>(1u << index);
		root.transitionLanes[index].reset();
		remaining &= ~lane;
	}
}

inline void movePendingFibersToMemoized(FiberRoot& root, Lanes lanes) {
	if (!enableUpdaterTracking) {
		return;
	}
	Lanes remaining = lanes;
	while (remaining != NoLanes) {
		const auto index = pickArbitraryLaneIndex(remaining);
		const auto lane = static_cast<Lane>(1u << index);
		auto& updaters = root.pendingUpdatersLaneMap[index];
		root.memoizedUpdaters.insert(updaters.begin(), updaters.end());
		updaters.clear();
		remaining &= ~lane;
	}
}

} // namespace react
