#pragma once

// Auto-generated by scripts/translate-react.js
// Source: react-main/packages/react-reconciler/src/ReactFiberWorkLoop.js

#include "react-reconciler/ReactFiber.h"
#include "react-reconciler/ReactFiberWorkLoopState.h"

#include <vector>

namespace react {

class ReactRuntime;

ExecutionContext getExecutionContext(ReactRuntime& runtime);
void setExecutionContext(ReactRuntime& runtime, ExecutionContext context);
void pushExecutionContext(ReactRuntime& runtime, ExecutionContext context);
void popExecutionContext(ReactRuntime& runtime, ExecutionContext context);

bool isAlreadyRendering(ReactRuntime& runtime);
bool isInvalidExecutionContextForEventFunction(ReactRuntime& runtime);

void setEntangledRenderLanes(ReactRuntime& runtime, Lanes lanes);
Lanes getEntangledRenderLanes(ReactRuntime& runtime);

FiberRoot* getWorkInProgressRoot(ReactRuntime& runtime);
void setWorkInProgressRoot(ReactRuntime& runtime, FiberRoot* root);
FiberNode* getWorkInProgressFiber(ReactRuntime& runtime);
void setWorkInProgressFiber(ReactRuntime& runtime, FiberNode* fiber);
Lanes getWorkInProgressRootRenderLanes(ReactRuntime& runtime);
void setWorkInProgressRootRenderLanes(ReactRuntime& runtime, Lanes lanes);
FiberNode* prepareFreshStack(ReactRuntime& runtime, FiberRoot& root, Lanes lanes);
void resetWorkInProgressStack(ReactRuntime& runtime);

void* getWorkInProgressUpdateTask(ReactRuntime& runtime);
void setWorkInProgressUpdateTask(ReactRuntime& runtime, void* task);
std::vector<const Transition*>& getWorkInProgressTransitions(ReactRuntime& runtime);
void clearWorkInProgressTransitions(ReactRuntime& runtime);
bool getDidIncludeCommitPhaseUpdate(ReactRuntime& runtime);
void setDidIncludeCommitPhaseUpdate(ReactRuntime& runtime, bool value);
double getGlobalMostRecentFallbackTime(ReactRuntime& runtime);
void setGlobalMostRecentFallbackTime(ReactRuntime& runtime, double value);
double getWorkInProgressRootRenderTargetTime(ReactRuntime& runtime);
void setWorkInProgressRootRenderTargetTime(ReactRuntime& runtime, double value);
void* getCurrentPendingTransitionCallbacks(ReactRuntime& runtime);
void setCurrentPendingTransitionCallbacks(ReactRuntime& runtime, void* callbacks);
double getCurrentEndTime(ReactRuntime& runtime);
void setCurrentEndTime(ReactRuntime& runtime, double time);
double getCurrentNewestExplicitSuspenseTime(ReactRuntime& runtime);
void setCurrentNewestExplicitSuspenseTime(ReactRuntime& runtime, double time);
void markCommitTimeOfFallback(ReactRuntime& runtime);
void resetRenderTimer(ReactRuntime& runtime);
double getRenderTargetTime(ReactRuntime& runtime);
PendingEffectsStatus getPendingEffectsStatus(ReactRuntime& runtime);
void setPendingEffectsStatus(ReactRuntime& runtime, PendingEffectsStatus status);
FiberRoot* getPendingEffectsRoot(ReactRuntime& runtime);
void setPendingEffectsRoot(ReactRuntime& runtime, FiberRoot* root);
FiberNode* getPendingFinishedWork(ReactRuntime& runtime);
void setPendingFinishedWork(ReactRuntime& runtime, FiberNode* fiber);
Lanes getPendingEffectsLanes(ReactRuntime& runtime);
void setPendingEffectsLanes(ReactRuntime& runtime, Lanes lanes);
Lanes getPendingEffectsRemainingLanes(ReactRuntime& runtime);
void setPendingEffectsRemainingLanes(ReactRuntime& runtime, Lanes lanes);
double getPendingEffectsRenderEndTime(ReactRuntime& runtime);
void setPendingEffectsRenderEndTime(ReactRuntime& runtime, double time);
std::vector<const Transition*>& getPendingPassiveTransitions(ReactRuntime& runtime);
void clearPendingPassiveTransitions(ReactRuntime& runtime);
std::vector<void*>& getPendingRecoverableErrors(ReactRuntime& runtime);
void clearPendingRecoverableErrors(ReactRuntime& runtime);
void* getPendingViewTransition(ReactRuntime& runtime);
void setPendingViewTransition(ReactRuntime& runtime, void* transition);
std::vector<void*>& getPendingViewTransitionEvents(ReactRuntime& runtime);
void clearPendingViewTransitionEvents(ReactRuntime& runtime);
void* getPendingTransitionTypes(ReactRuntime& runtime);
void setPendingTransitionTypes(ReactRuntime& runtime, void* types);
bool getPendingDidIncludeRenderPhaseUpdate(ReactRuntime& runtime);
void setPendingDidIncludeRenderPhaseUpdate(ReactRuntime& runtime, bool value);
SuspendedCommitReason getPendingSuspendedCommitReason(ReactRuntime& runtime);
void setPendingSuspendedCommitReason(ReactRuntime& runtime, SuspendedCommitReason reason);
std::uint32_t getNestedUpdateCount(ReactRuntime& runtime);
void setNestedUpdateCount(ReactRuntime& runtime, std::uint32_t count);
FiberRoot* getRootWithNestedUpdates(ReactRuntime& runtime);
void setRootWithNestedUpdates(ReactRuntime& runtime, FiberRoot* root);
bool getIsFlushingPassiveEffects(ReactRuntime& runtime);
void setIsFlushingPassiveEffects(ReactRuntime& runtime, bool value);
bool getDidScheduleUpdateDuringPassiveEffects(ReactRuntime& runtime);
void setDidScheduleUpdateDuringPassiveEffects(ReactRuntime& runtime, bool value);
std::uint32_t getNestedPassiveUpdateCount(ReactRuntime& runtime);
void setNestedPassiveUpdateCount(ReactRuntime& runtime, std::uint32_t count);
FiberRoot* getRootWithPassiveNestedUpdates(ReactRuntime& runtime);
void setRootWithPassiveNestedUpdates(ReactRuntime& runtime, FiberRoot* root);
bool getIsRunningInsertionEffect(ReactRuntime& runtime);
void setIsRunningInsertionEffect(ReactRuntime& runtime, bool value);
bool hasPendingCommitEffects(ReactRuntime& runtime);
FiberRoot* getRootWithPendingPassiveEffects(ReactRuntime& runtime);
Lanes getPendingPassiveEffectsLanes(ReactRuntime& runtime);
bool isWorkLoopSuspendedOnData(ReactRuntime& runtime);
double getCurrentTime(ReactRuntime& runtime);

void markSkippedUpdateLanes(ReactRuntime& runtime, Lanes lanes);
void renderDidSuspend(ReactRuntime& runtime);
void renderDidSuspendDelayIfPossible(ReactRuntime& runtime);
void renderDidError(ReactRuntime& runtime);
void queueConcurrentError(ReactRuntime& runtime, void* error);
bool renderHasNotSuspendedYet(ReactRuntime& runtime);
void markSpawnedRetryLane(ReactRuntime& runtime, Lane lane);

SuspendedReason getWorkInProgressSuspendedReason(ReactRuntime& runtime);
void setWorkInProgressSuspendedReason(ReactRuntime& runtime, SuspendedReason reason);

void* getWorkInProgressThrownValue(ReactRuntime& runtime);
void setWorkInProgressThrownValue(ReactRuntime& runtime, void* value);

bool getWorkInProgressRootDidSkipSuspendedSiblings(ReactRuntime& runtime);
void setWorkInProgressRootDidSkipSuspendedSiblings(ReactRuntime& runtime, bool value);

bool getWorkInProgressRootIsPrerendering(ReactRuntime& runtime);
void setWorkInProgressRootIsPrerendering(ReactRuntime& runtime, bool value);

bool getWorkInProgressRootDidAttachPingListener(ReactRuntime& runtime);
void setWorkInProgressRootDidAttachPingListener(ReactRuntime& runtime, bool value);

RootExitStatus getWorkInProgressRootExitStatus(ReactRuntime& runtime);
void setWorkInProgressRootExitStatus(ReactRuntime& runtime, RootExitStatus status);

Lanes getWorkInProgressRootSkippedLanes(ReactRuntime& runtime);
void setWorkInProgressRootSkippedLanes(ReactRuntime& runtime, Lanes lanes);

Lanes getWorkInProgressRootInterleavedUpdatedLanes(ReactRuntime& runtime);
void setWorkInProgressRootInterleavedUpdatedLanes(ReactRuntime& runtime, Lanes lanes);

Lanes getWorkInProgressRootRenderPhaseUpdatedLanes(ReactRuntime& runtime);
void setWorkInProgressRootRenderPhaseUpdatedLanes(ReactRuntime& runtime, Lanes lanes);

Lanes getWorkInProgressRootPingedLanes(ReactRuntime& runtime);
void setWorkInProgressRootPingedLanes(ReactRuntime& runtime, Lanes lanes);

Lane getWorkInProgressDeferredLane(ReactRuntime& runtime);
void setWorkInProgressDeferredLane(ReactRuntime& runtime, Lane lane);

Lanes getWorkInProgressSuspendedRetryLanes(ReactRuntime& runtime);
void setWorkInProgressSuspendedRetryLanes(ReactRuntime& runtime, Lanes lanes);

std::vector<void*>& getWorkInProgressRootConcurrentErrors(ReactRuntime& runtime);
void clearWorkInProgressRootConcurrentErrors(ReactRuntime& runtime);

std::vector<void*>& getWorkInProgressRootRecoverableErrors(ReactRuntime& runtime);
void clearWorkInProgressRootRecoverableErrors(ReactRuntime& runtime);

bool getWorkInProgressRootDidIncludeRecursiveRenderUpdate(ReactRuntime& runtime);
void setWorkInProgressRootDidIncludeRecursiveRenderUpdate(ReactRuntime& runtime, bool value);

void panicOnRootError(ReactRuntime& runtime, FiberRoot& root, void* error);
void completeUnitOfWork(ReactRuntime& runtime, FiberNode& unitOfWork);
void unwindUnitOfWork(ReactRuntime& runtime, FiberNode& unitOfWork, bool skipSiblings);
void throwAndUnwindWorkLoop(
	ReactRuntime& runtime,
	FiberRoot& root,
	FiberNode& unitOfWork,
	void* thrownValue,
	SuspendedReason reason);
void performUnitOfWork(ReactRuntime& runtime, FiberNode& unitOfWork);
void workLoopSync(ReactRuntime& runtime);
void workLoopConcurrent(ReactRuntime& runtime, bool nonIdle);
void workLoopConcurrentByScheduler(ReactRuntime& runtime);
RootExitStatus renderRootSync(
	ReactRuntime& runtime,
	FiberRoot& root,
	Lanes lanes,
	bool shouldYieldForPrerendering);
RootExitStatus renderRootConcurrent(
	ReactRuntime& runtime,
	FiberRoot& root,
	Lanes lanes);

} // namespace react
